/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */



package javax.net.ssl;


/**
 * An encapsulation of the result state produced by
 * <code>SSLEngine</code> I/O calls.
 *
 * <p> A <code>SSLEngine</code> provides a means for establishing
 * secure communication sessions between two peers.  <code>SSLEngine</code>
 * operations typically consume bytes from an input buffer and produce
 * bytes in an output buffer.  This class provides operational result
 * values describing the state of the <code>SSLEngine</code>, including
 * indications of what operations are needed to finish an
 * ongoing handshake.  Lastly, it reports the number of bytes consumed
 * and produced as a result of this operation.
 *
 * @see javax.net.ssl.SSLEngine
 * @see SSLEngine#wrap(ByteBuffer, ByteBuffer)
 * @see SSLEngine#unwrap(ByteBuffer, ByteBuffer)
 *
 * @author Brad R. Wetmore
 * @since 1.5
 * @apiSince 1
 */

@SuppressWarnings({"unchecked", "deprecation", "all"})
public class SSLEngineResult {

/**
 * Initializes a new instance of this class.
 *
 * @param   status
 *          the return value of the operation.
 *
 * @param   handshakeStatus
 *          the current handshaking status.
 *
 * @param   bytesConsumed
 *          the number of bytes consumed from the source ByteBuffer
 *
 * @param   bytesProduced
 *          the number of bytes placed into the destination ByteBuffer
 *
 * @throws  java.lang.IllegalArgumentException
 *          if the <code>status</code> or <code>handshakeStatus</code>
 *          arguments are null, or if <code>bytesConsumed</code> or
 *          <code>bytesProduced</code> is negative.
 * @apiSince 1
 */

public SSLEngineResult(javax.net.ssl.SSLEngineResult.Status status, javax.net.ssl.SSLEngineResult.HandshakeStatus handshakeStatus, int bytesConsumed, int bytesProduced) { throw new RuntimeException("Stub!"); }

/**
 * Gets the return value of this <code>SSLEngine</code> operation.
 *
 * @return  the return value
 * @apiSince 1
 */

public final javax.net.ssl.SSLEngineResult.Status getStatus() { throw new RuntimeException("Stub!"); }

/**
 * Gets the handshake status of this <code>SSLEngine</code>
 * operation.
 *
 * @return  the handshake status
 * @apiSince 1
 */

public final javax.net.ssl.SSLEngineResult.HandshakeStatus getHandshakeStatus() { throw new RuntimeException("Stub!"); }

/**
 * Returns the number of bytes consumed from the input buffer.
 *
 * @return  the number of bytes consumed.
 * @apiSince 1
 */

public final int bytesConsumed() { throw new RuntimeException("Stub!"); }

/**
 * Returns the number of bytes written to the output buffer.
 *
 * @return  the number of bytes produced
 * @apiSince 1
 */

public final int bytesProduced() { throw new RuntimeException("Stub!"); }

/**
 * Returns a String representation of this object.
 * @apiSince 1
 */

public java.lang.String toString() { throw new RuntimeException("Stub!"); }
/**
 * An <code>SSLEngineResult</code> enum describing the current
 * handshaking state of this <code>SSLEngine</code>.
 *
 * @author Brad R. Wetmore
 * @since 1.5
 * @apiSince 1
 */

@SuppressWarnings({"unchecked", "deprecation", "all"})
public enum HandshakeStatus {
/**
 * The <code>SSLEngine</code> is not currently handshaking.
 * @apiSince 1
 */

NOT_HANDSHAKING,
/**
 * The <code>SSLEngine</code> has just finished handshaking.
 * <P>
 * This value is only generated by a call to
 * <code>SSLEngine.wrap()/unwrap()</code> when that call
 * finishes a handshake.  It is never generated by
 * <code>SSLEngine.getHandshakeStatus()</code>.
 *
 * @see SSLEngine#wrap(ByteBuffer, ByteBuffer)
 * @see SSLEngine#unwrap(ByteBuffer, ByteBuffer)
 * @see javax.net.ssl.SSLEngine#getHandshakeStatus()
 * @apiSince 1
 */

FINISHED,
/**
 * The <code>SSLEngine</code> needs the results of one (or more)
 * delegated tasks before handshaking can continue.
 *
 * @see javax.net.ssl.SSLEngine#getDelegatedTask()
 * @apiSince 1
 */

NEED_TASK,
/**
 * The <code>SSLEngine</code> must send data to the remote side
 * before handshaking can continue, so <code>SSLEngine.wrap()</code>
 * should be called.
 *
 * @see SSLEngine#wrap(ByteBuffer, ByteBuffer)
 * @apiSince 1
 */

NEED_WRAP,
/**
 * The <code>SSLEngine</code> needs to receive data from the
 * remote side before handshaking can continue.
 * @apiSince 1
 */

NEED_UNWRAP;
}

/**
 * An <code>SSLEngineResult</code> enum describing the overall result
 * of the <code>SSLEngine</code> operation.
 *
 * The <code>Status</code> value does not reflect the
 * state of a <code>SSLEngine</code> handshake currently
 * in progress.  The <code>SSLEngineResult's HandshakeStatus</code>
 * should be consulted for that information.
 *
 * @author Brad R. Wetmore
 * @since 1.5
 * @apiSince 1
 */

@SuppressWarnings({"unchecked", "deprecation", "all"})
public enum Status {
/**
 * The <code>SSLEngine</code> was not able to unwrap the
 * incoming data because there were not enough source bytes
 * available to make a complete packet.
 *
 * <P>
 * Repeat the call once more bytes are available.
 * @apiSince 1
 */

BUFFER_UNDERFLOW,
/**
 * The <code>SSLEngine</code> was not able to process the
 * operation because there are not enough bytes available in the
 * destination buffer to hold the result.
 * <P>
 * Repeat the call once more bytes are available.
 *
 * @see javax.net.ssl.SSLSession#getPacketBufferSize()
 * @see javax.net.ssl.SSLSession#getApplicationBufferSize()
 * @apiSince 1
 */

BUFFER_OVERFLOW,
/**
 * The <code>SSLEngine</code> completed the operation, and
 * is available to process similar calls.
 * @apiSince 1
 */

OK,
/**
 * The operation just closed this side of the
 * <code>SSLEngine</code>, or the operation
 * could not be completed because it was already closed.
 * @apiSince 1
 */

CLOSED;
}

}

